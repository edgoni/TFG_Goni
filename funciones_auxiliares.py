# -*- coding: utf-8 -*-
"""funciones_auxiliares.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sy12VmhYzKoOTCydV18gqH_z9xWJUdRP
"""

import numpy as np
import jax
import jax.numpy as jnp

def get_adjacency_matrix(N):#al parecer en netket hay una funcion que te obtiene esto ya

    '''
    Extrae la matriz de adyacencia de primeros vecinos.

    Entrada: -Número de spins

    Salida: -Adjacency matrix of the graph
    '''

    adjacency_matrix = jnp.eye(N, k=1) + jnp.eye(N, k=-1)

    adjacency_matrix = adjacency_matrix.at[0, -1].set(1)
    adjacency_matrix = adjacency_matrix.at[-1, 0].set(1)

    return adjacency_matrix

def get_edge(matrix, N):  #Podemos obtener la matriz directamente aqui dentro
    '''
    Devuelve las conexiones de un grafo.

    Entrada: -matrix: Matriz de adyacencia
             -N: Número de espines

    Salida: -edges: Lista de aristas con el nodo de origen en la primera columna,
                    el nodo destino  en la segunda (number_edges, 2)

    '''
    if matrix.ndim != 2:
        raise ValueError("La matriz debe ser de 2 dimensiones.")
    # jnp.argwhere devuelve las coordenadas donde la condición se cumple.
    edges = jnp.argwhere(matrix == 1, size=2*N)  # Specify size using N
    return edges

def vecinos_por_nodo(N):
    """
    Obtiene los vecinos de cada nodo en un grafo.

    Entrada: -N: Número de espines

    Salida: - vecinos_por_nodo: Diccionario de vecinos por nodo.Los vecinos se representan como los índices que ocupan en el array 'edges'

    """
    # Convertimos edges a un array de NumPy para evitar problemas con trazado de JAX.
    edges_np = np.array(get_edge(get_adjacency_matrix(N),N))
    num_nodes = get_adjacency_matrix(N).shape[0]
    vecinos_por_nodo = {}

    for i in range(num_nodes):
        # np.where retorna los índices donde se cumple la condición
        indices = np.where(edges_np[:, 0] == i)[0].tolist()
        vecinos_por_nodo[i] = indices

    return vecinos_por_nodo

def suma_resultados_con_indices(resultados_mlp, node_features, vecinos_tuple):
    '''
    Suma los resultados de los mensajes de los vecinos indicados por los indices.

    Entrada:
      -resultados_mlp: mensajes
      -node_features: características de nodo
      -vecinos_tuple: vecinos por nodo (el diccionario convertido a tupla)
        se usa vecinos para sólo construir el mensaje con la suma de nodos vecinos

    Salida:
      -resultados_sumados: resultados de la suma de los mensajes de los vecinos
    '''

    resultados_sumados = jnp.zeros(node_features.shape[0])

    for nodo, indices_vecinos in vecinos_tuple:

        indices_vecinos_array = jnp.array(indices_vecinos)

        suma_vecinos = jnp.sum(resultados_mlp[indices_vecinos_array])  # Sumar resultados de vecinos indicados por los indices

        resultados_sumados = resultados_sumados.at[nodo].set(suma_vecinos)  # Asignar suma al nodo actual
    return resultados_sumados

def obtain_origin_goal(node_features, edge_features):
    '''
    Obtiene las características de los nodos de origen y destino de las conexiones.

    Entrada:
      -node_features: array con información de nodo (batch, N , 5)
      -edge_features: array con información de arista(num conexiones, 2)

    Salida:
      -origin_input: array con todos los nodos de origen y la informacion de cada nodo (num conexiones, feature node origin)
      -goal_input: array con todos los nodos de destino y la informacion de cada nodo (num conexiones, feature node goal)

    '''
    origin_input=[]
    goal_input=[]
    node_features_spin = node_features[:,:,0]

    for i in range(len(edge_features)):# con ayuda de las edge_features, que nos dicen tambien como se relacionan los nodos, obtenemos las listas de origin, goal
      origin=edge_features[i][0]
      goal=edge_features[i][1]
      origin_input.append(node_features_spin[:,origin]) # para cada batch obtenemos los node_features del origen de cada conexion
      goal_input.append(node_features_spin[:,goal]) # lo mismo para el destino

    origin_input=jnp.array(origin_input)
    goal_input=jnp.array(goal_input)

    origin_input = jnp.stack(origin_input, axis=1)
    goal_input   = jnp.stack(goal_input, axis=1)

    return origin_input, goal_input

def get_exchange_matrix(N_norm, b, N, alpha, J):
  '''
  Pasamos todo lo necesario para obtener los coeficientes de intercambio del Hamiltoniano.
  Construimos la matriz con los coeficientes de intercambio de los espines i, j.
  Queremos una matriz que nos muestre estos en la diagonal debera de estar b.

  Entradas:
            -N_norm: constante normalización de los coeficientes de intercambio
            -b: constante de intercambio para i = j.
            -N: número de espines
            -alpha: rango del hamiltoniano
            -J: constante global de intercambio

  Salida:
            -coefficient_matrix: matriz de coeficientes de intercambio
  '''
  coefficient_matrix = np.zeros((N, N))
  #calculamos las distancias
  for i in range(N):
    for j in range(N):
      if i!=j:
        distancia = jnp.min(jnp.array([jnp.abs(i-j), N-jnp.abs(i-j)])) # bboundary conditions
        distancia = distancia.astype(float) **(-alpha)
        coefficient_matrix[i,j] = distancia

      else:
        distancia = b
        coefficient_matrix[i,j] = distancia

  coefficient_matrix = J/N_norm * coefficient_matrix

  coefficient_matrix = jnp.array(coefficient_matrix)

  return coefficient_matrix

def get_exchange_coefficients(edges, exchange_matrix):
  '''
  Le pasamos las conexiones y la matriz de intercambio, y selecciona solo los coeficientes de intercambio de las conexiones.
  Si i y j estan conectados nos devuelve pues J_{ij}.

  Entradas:
            -edges: conexiones
            -exchange_matrix: matriz de intercambio

  Salida:
            -exchange_coefficient: coeficientes de intercambio de las conexiones
  '''
  exchange_coefficient = jnp.zeros(edges.shape[0])

  # Using jax.vmap for efficient vectorized operation
  def get_coefficient(edge):
    return exchange_matrix[edge[0], edge[1]]

  exchange_coefficient = jax.vmap(get_coefficient)(edges)
  return exchange_coefficient

def get_normalized_matrix(W):
    '''
    Funcion para normalizar una matriz W.

    Entrada: -W: Matriz a normalizar

    Salida: -W_hat: Matriz normalizada
    '''
    W = (np.eye(W.shape[0]) + W)
    D = np.sum(W, axis=1)
    D_sqrt_inv = np.diag(1.0 / np.sqrt(np.where(D > 0, D, 1e-8)))  # evitar división por cero
    W_hat = D_sqrt_inv @ W @ D_sqrt_inv
    return W_hat