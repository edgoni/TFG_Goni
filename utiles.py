# -*- coding: utf-8 -*-
"""utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Piq9uxOhvNrfwKW4W_LSf21kgwQ1JVTg
"""

'''
Funciones auxiliares obtenidas del repositorio https://github.com/Theory-and-Simulation-at-INMA/transformer_LR_WF_public para asegurar
la validez de replicar las simulaciones presentadas en el artículo de donde se obtiene el ViT.
'''

import copy
import pathlib
from typing import Optional

import flax
import jax
import jax.numpy as jnp
import numpy as np
import numpy.typing as npt
from netket.sampler import MetropolisRule
from netket.utils.struct import dataclass

REAL_DTYPE = jnp.asarray(1.0).dtype


def circulant(
    row: npt.ArrayLike, times: Optional[int] = None
) -> npt.ArrayLike:
    """Construye una matriz circulante (completa o parcial) a partir de un array.

    Argumentos:
        row: La primera fila de la matriz.
        times: Si no es None, el número de filas a generar.

    Devuelve:
        Si `times` es None, una matriz cuadrada con todas las versiones desplazadas
        del primer argumento. En caso contrario, `times` filas de una matriz circulante.
    """

    row = jnp.asarray(row)

    def scan_arg(carry, _):
        new_carry = jnp.roll(carry, -1)
        return (new_carry, new_carry)

    if times is None:
        nruter = jax.lax.scan(scan_arg, row, row)[1][::-1, :]
    else:
        nruter = jax.lax.scan(scan_arg, row, None, length=times)[1][::-1, :]

    return nruter


class BestIterKeeper:
    """Almacena los valores de varias cantidades de la mejor iteración.

    "Mejor" se define en el sentido de menor energía.

    Argumentos:
        Hamiltoniano: Un array que contiene la matriz del Hamiltoniano.
        N: Número de espines en la cadena.
        baseline: Un límite inferior para la puntuación V. Si la puntuación V
            de la mejor iteración cae por debajo de este umbral, el proceso
            se detendrá antes.
        filename: Puede ser None o un archivo donde se escribirá el mejor estado.
    """

    def __init__(
        self,
        Hamiltonian: npt.ArrayLike,
        N: int,
        baseline: float,
        filename: Optional[pathlib.Path] = None,
    ):
        self.Hamiltonian = Hamiltonian
        self.N = N
        self.baseline = baseline
        self.filename = filename
        self.vscore = np.inf
        self.best_energy = np.inf
        self.best_state = None

    def update(self, step, log_data, driver):
        """Actualiza las cantidades almacenadas si es necesario.

        Esta función está diseñada para actuar como una función de *callback* para NetKet.
        Por favor, consulta la documentación de su API para una explicación detallada.
        """

        vstate = driver.state
        energystep = np.real(vstate.expect(self.Hamiltonian).mean)
        var = np.real(getattr(log_data[driver._loss_name], "variance"))
        mean = np.real(getattr(log_data[driver._loss_name], "mean"))
        varstep = self.N * var / mean**2

        if self.best_energy > energystep:
            self.best_energy = energystep
            self.best_state = copy.copy(driver.state)
            self.best_state.parameters = flax.core.copy(
                driver.state.parameters
            )
            self.vscore = varstep

            if self.filename != None:
                with open(self.filename, "wb") as file:
                    file.write(flax.serialization.to_bytes(driver.state))

        return self.vscore > self.baseline


@dataclass
class InvertMagnetization(MetropolisRule):
    """Regla de mutación de Monte Carlo que invierte todos los espines.

    Por favor, consulta la documentación de la API de NetKet para una explicación detallada
    de la interfaz MetropolisRule.
    """

    def transition(rule, sampler, machine, parameters, state, key, σ):
        indxs = jax.random.randint(
            key, shape=(1,), minval=0, maxval=sampler.n_chains
        )
        σp = σ.at[indxs, :].multiply(-1)
        return σp, None