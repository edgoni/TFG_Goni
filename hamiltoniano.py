# -*- coding: utf-8 -*-
"""hamiltonian.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HIeNl420_k5ZSuFdpzp9G021VxzKAfpa
"""

'''
Funciones auxiliares obtenidas del repositorio https://github.com/Theory-and-Simulation-at-INMA/transformer_LR_WF_public para asegurar
la validez de replicar las simulaciones presentadas en el artículo de donde se obtiene el ViT.
'''

from typing import Optional, Tuple
import netket as nk
import numpy.typing as npt
from netket.operator.spin import sigmax, sigmaz


def get_Hamiltonian(
    N: int,
    J: float,
    alpha: float,
    trans_field: float = -1.0,
    sym_field: Optional[bool] = False,
    epsilon: Optional[float] = 1e-3,
    return_norm: Optional[float] = False,
) -> Tuple[npt.ArrayLike, float]:
    """Construye el Hamiltoniano del sistema.

    Argumentos:
        N: Número de espines en la cadena.
        J: Intensidad de la interacción espín-espín sin correcciones.
        alpha: Exponente de la ley de potencias que rige la disminución
            de la intensidad de la interacción.
        trans_field: Componente transversal de un campo externo.
        sym_field: Componente longitudinal de un campo externo.
        epsilon: Intensidad relativa de la componente longitudinal respecto
            a la intensidad de interacción.
        return_norm: Indicador que permite a la función devolver el valor de la
            constante de normalización.

    Devuelve:
        H o la tupla (H, N_norm), dependiendo de si return_norm es True.
            H: Matriz que contiene el Hamiltoniano.
            N_norm: Valor en coma flotante de la constante de normalización.
    """

    hi = nk.hilbert.Spin(s=1 / 2, N=N)
    H = sum(trans_field * sigmax(hi, i) for i in range(N))

    N_norm = 1
    for i in range(1, N):
        dist = min(abs(i), N - abs(i))
        N_norm += 1 / dist**alpha

    J = J / N_norm

    for i in range(0, N):
        for j in range(i, N):
            dist = min(abs(i - j), N - abs(i - j))
            cn = 1.0
            if dist == 0:
                dist = 1
                cn = 2.0
            H += J / cn * sigmaz(hi, i) * sigmaz(hi, j) / (dist**alpha)

    if sym_field:
        H += J * epsilon * sum(sigmaz(hi, i) for i in range(N))

    H /= N
    if return_norm:
        return (H, N_norm)
    else:
        return H


def get_eigvals(
    Hamiltonian: npt.ArrayLike, order: int = 1, eigenvecs: bool = False
) -> Tuple[npt.ArrayLike, npt.ArrayLike]:

    """Diagonaliza parcialmente una matriz dada, concretamente el Hamiltoniano.

        Argumentos:
            Hamiltoniano: Hamiltoniano o matriz general a diagonalizar.
            order: Número de niveles de energía más bajos que se desea obtener.
            eigenvecs: Si se establece en True, también devuelve un array con los
                autovectores correspondientes a los autovalores obtenidos.

        Devuelve:
            w o la tupla (w, v), dependiendo de si compute_eigenvectors es True.
                w: Array que contiene los 'order' autovalores más bajos.
                v: Array que contiene los autovectores como columnas, de forma que
                    'v[:, i]' corresponde a w[i].
    """

    return nk.exact.lanczos_ed(
        Hamiltonian, k=order, compute_eigenvectors=eigenvecs
    )